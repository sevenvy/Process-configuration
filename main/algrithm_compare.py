import csv
import os
import math
import copy


if __name__ == '__main__': # 这里主要是用来避免多进程/线程时,反复重新导入数据
    # 要评估的加工特征序列
    feature_solution_num = 1

    # 测试次数编号
    test_num = 1


'''定义最佳前沿数据读取函数'''
def front_read(path):
    data_txt = []
    with open(path, 'r') as f: # 读取csv文件，可参考：https://www.cnblogs.com/xbhog/p/13141128.html
        reader = csv.reader(f)
        for line in reader:
            data_txt.append(line)
    result = []
    for flag1 in range(len(data_txt)):
        data1 = []
        for flag2 in range(len(data_txt[flag1])):
            if data_txt[flag1][flag2][0:2] == '[[': # 对于包含‘[[]]’的项，需要将里边的数字提取出来
                a = data_txt[flag1][flag2][2:len(data_txt[flag1][flag2])-2] # 去掉最外层的‘[[’和‘]]’
                b = a.split('], [') # 对字符串a进行切分
                c = []
                for b1 in b:
                    b2 = b1.split(', ') # 对字符串b1进行切分
                    b3 = list(map(eval,b2)) # 将切分好的字符串序列转换成数字
                    c.append(b3)
            elif data_txt[flag1][flag2][0:1] == '[': # 对于包含‘[]’的项，需要将里边的数字提取出来
                a = data_txt[flag1][flag2][1:len(data_txt[flag1][flag2])-1] # 去掉最外层的‘[’和‘]’
                b = a.split(', ') # 对字符串a进行切分
                c = list(map(eval,b)) # 将切分好的字符串序列转换成数字
            data1.append(c)
        result.append(data1)
    return result


'''定义整理前沿形成非支配排序的输入参数形式的函数'''
def tidy(result):
    X = []
    objects_X = []
    SE_X = []
    for a in result: # 统计最佳前沿中所涉及的解
        if a[0:2] not in X:
            X.append(a[0:2])
            objects_X.append([a[-1]])
            SE_X.append([a[2]])
        else:
            b = X.index(a[0:2])
            objects_X[b].append(a[-1])
            SE_X[b].append(a[2])
    return X, objects_X, SE_X


'''定义各次计算最佳前沿目标数据读取函数'''
def object_read(path):
    data = []
    with open(path, 'r') as f: # 读取csv文件，可参考：https://www.cnblogs.com/xbhog/p/13141128.html
        reader = csv.reader(f)
        for line in reader:
            data.append(list(map(eval,line))) # 每一行，第一个数据为迭代次数，第二个数据为计算耗时，第三到最后为各优化目标值
    results = [[]]
    k = 0 # 迭代次数编号
    for i in range(len(data)):
        if data[i][0] == k:
            results[-1].append(data[i][2:])
        else:
            results.append([data[i][2:]])
            k += 1
    return results


'''定义计算时间读取函数'''
def time_read(path):
    with open(path, 'r') as f: # 读取csv文件，可参考：https://www.cnblogs.com/xbhog/p/13141128.html
        reader = csv.reader(f)
        time = list(map(eval, next(reader)))[0] # 读取第一行
    return time


'''非支配排序（以拆开的解及其目标和数量布局方案为输入，所有前沿为输出）'''
# 输入：
# N 种群个体数量；P_C 父代与子代的集合；objects_calculation 目标函数计算结果，其维度为[个体*设备数量配置方案*目标函数值]；i_j 父代与子代的集合中各加工特征所选取的五元组合编号的列表;
# SE_set 所有个体的设备数量配置与布局方案(每个设备型号选择多少台设备，以及各台设备的位置)，其维度为[个体*设备数量配置与布局方案*[每个设备型号选择的设备数量, 每个设备的位置]]；
# 输出：
# fronts 前几个前沿的集合，其中每个二级元素包含 [[各加工特征的五元组合], [各五元组合编号], [设备数量与布局配置方案], [各目标函数值]]
# num 已划分完成的前沿中所涉及的个体总数；A 目前分配好的前沿中已经涉及的个体信息，每行包含[[各加工特征的五元组合], [各五元组合编号]]
def ENS_5(solutions, objects_calculation, SE_set): # 采用高效非支配排序方法（ENS）
    # 将几个集合合并一下便于后续操作
    E = []
    for i in range(len(solutions)):
        for j in range(len(SE_set[i])):
            E.append([solutions[i][0], solutions[i][1], SE_set[i][j], objects_calculation[i][j]])

    # 根据第一个目标函数值对所有元素进行排序，如果第一个目标函数值相等，则根据第二个目标函数值排序，依此类推，如果全都相等，则任意排列
    def sort_key1(elem): # 设置一个函数，用于根据第一个目标函数值排序
        return elem[-1][0]
    
    def sort_key2(elem): # 设置一个函数，用于根据第二个目标函数值排序
        return elem[-1][1]

    def sort_key3(elem): # 设置一个函数，用于根据第三个目标函数值排序
        return elem[-1][2]

    def sort_key4(elem): # 设置一个函数，用于根据第四个目标函数值排序
        return elem[-1][3]
    
    E.sort(key=sort_key1) # 根据第一个目标函数值排序

    n1 = 0
    while n1 < len(E)-1: # 找出第一个目标函数值相等的连续几个元素
        if E[n1][-1][0] == E[n1+1][-1][0]: # 有两个相等
            A1 = [E[n1], E[n1+1]]
            k1 = 1
            while n1+k1 < len(E)-1 and E[n1+k1][-1][0] == E[n1+k1+1][-1][0]: # 判断是否还有三个或三个以上相等的
                A1.append(E[n1+k1+1])
                k1 += 1
            A1.sort(key=sort_key2) # 根据第二个目标函数值排序
            E[n1:n1+k1+1] = A1[:]

            n2 = 0
            while n2 < len(A1)-1: # 找出第二个目标函数值相等的连续几个元素
                if A1[n2][-1][1] == A1[n2+1][-1][1]: # 有两个相等
                    A2 = [A1[n2], A1[n2+1]]
                    k2 = 1
                    while n2+k2 < len(A1)-1 and A1[n2+k2][-1][1] == A1[n2+k2+1][-1][1]: # 判断是否还有三个或三个以上相等的
                        A2.append(A1[n2+k2+1])
                        k2 += 1
                    A2.sort(key=sort_key3) # 根据第三个目标函数值排序
                    E[n1+n2:n1+n2+k2+1] = A2[:]

                    n3 = 0
                    while n3 < len(A2)-1: # 找出第三个目标函数值相等的连续几个元素
                        if A2[n3][-1][2] == A2[n3+1][-1][2]: # 有两个相等
                            A3 = [A2[n3], A2[n3+1]]
                            k3 = 1
                            while n3+k3 < len(A2)-1 and A2[n3+k3][-1][2] == A1[n3+k3+1][-1][2]: # 判断是否还有三个或三个以上相等的
                                A3.append(A2[n3+k3+1])
                                k3 += 1
                            A3.sort(key=sort_key4) # 根据第四个目标函数值排序
                            E[n1+n2+n3:n1+n2+n3+k3+1] = A3[:] # 如果还有第四个目标函数值相等，则任意排列即可，这里就不再操作
                            n3 += k3 + 1
                        else:
                            n3 += 1
                    n2 += k2 + 1
                else:
                    n2 += 1   
            n1 += k1 + 1         
        else:
            n1 += 1        

    # 将排好序的元素依次分配到各前沿中
    fronts = [[E[0]]] # 第一个元素必定在第一个前沿中
    for i in range(1,len(E)):
        k1 = 0 # 是否已经完成当前元素的前沿分配的标志
        f = 0 # pareto前沿序号
        for f in range(len(fronts)):
            k2 = 0 # 当前前沿是否存在支配解的标志
            for j in range(len(fronts[f])-1, -1, -1): # 支配关系确认，按照算法，从当前前沿中最后一个元素往前判断
                if E[i][-1][0] >= fronts[f][j][-1][0] and E[i][-1][1] >= fronts[f][j][-1][1] and E[i][-1][2] >= fronts[f][j][-1][2] and E[i][-1][3] >= fronts[f][j][-1][3] and E[i][-1] != fronts[f][j][-1]:
                    k2 = 1
                    break # 只要存在一个支配解，就退出循环
            if k2 == 0:
                fronts[f].append(E[i])
                k1 = 1
                break
        if k1 == 0: # 如果前边的前沿均存在支配元素，则将当前元素放到新的一个前沿中
            fronts.append([E[i]])

    return fronts


'''快速非支配排序(仅包含各目标值作为输入，最佳前沿作为输出)'''
# 输入：
# E 每行形式为[目标1，目标2，……]
def ENS_3(E): # 采用高效非支配排序方法（ENS）
    # 根据第一个目标函数值对所有元素进行由小到大排序，如果第一个目标函数值相等，则根据第二个目标函数值排序，依此类推，如果全都相等，则任意排列
    object_num = len(E[0]) # 优化目标数量
    for k in range(object_num):
        if k == 0:
            E.sort(key=lambda x:x[0]) # 根据第一个目标函数值排序
        else:
            i = 0
            while i < len(E):
                head = E[i][0:k]
                j = i
                while j < len(E) and E[j][0:k] == head:
                    j += 1
                E1 = E[i:j]
                E1.sort(key=lambda x:x[k])
                E[i:j] = E1
                i = j

    # 在排好序的元素中获取最佳前沿
    front = [E[0]]
    for i in range(1,len(E)):
        for j in range(len(front)-1, -1, -1): # 支配关系确认，按照算法，从当前前沿中最后一个元素往前判断
            flag = 0
            if E[i] != front[j]:
                for k in range(1,object_num):
                    if E[i][k] < front[j][k]: # 但凡前沿解元素的某个目标值大于评估解，则必定相互不支配
                        flag = 1
                        break
            else:
                flag = 1 # 如果相同，则也不相互支配
                break
            if flag == 0:
                break # 只要存在一个支配解，就退出循环
        if flag == 1:
            front.append(E[i])

    return front


"""计算超体积"""
# 首先，将需要进行比较的最佳前沿都整理一下，形成只保留几个优化目标的集合，每行元素的形式为[目标1，目标2，……]

# 进行规范化处理，取所有待比较的结果中各目标的最大值和最小值，分别将各目标缩放到[0，1]范围内

# 由于超体积计算的目标通常为越大越好，而这里是越小越好，因此参考点取为[1, 1, 1, 1], 为了计算超体积时方便，将所有目标值都用1减一下，转换成通常情况下超体积计算的形态

# 快速非支配排序
# 输入：
# E 每行形式为[目标1，目标2，……，x]，其中x为求超体积时添加的参数值
def ENS_2(E): # 采用高效非支配排序方法（ENS）
    # 根据第一个目标函数值对所有元素进行由大到小排序，如果第一个目标函数值相等，则根据第二个目标函数值排序，依此类推，如果全都相等，则任意排列
    object_num = len(E[0]) - 1 # 优化目标数量
    for k in range(object_num):
        if k == 0:
            E.sort(key=lambda x:x[0], reverse=True) # 根据第一个目标函数值排序
        else:
            i = 0
            while i < len(E):
                head = E[i][0:k]
                j = i
                while j < len(E) and E[j][0:k] == head:
                    j += 1
                E1 = E[i:j]
                E1.sort(key=lambda x:x[k], reverse=True)
                E[i:j] = E1
                i = j

    # 在排好序的元素中获取最差前沿，因为后边求超体积时需要求包络面
    front = [E[0]]
    for i in range(1,len(E)):
        for j in range(len(front)-1, -1, -1): # 支配关系确认，按照算法，从当前前沿中最后一个元素往前判断
            flag = 0
            if E[i][0:object_num] != front[j][0:object_num]:
                for k in range(1,object_num):
                    if E[i][k] > front[j][k]:
                        flag = 1
                        break
            if flag == 0:
                break # 只要存在一个支配解，就退出循环
        if flag == 1:
            front.append(E[i])

    return front


# 采用Hypervolume by Slicing Objectives (HSO)算法求超体积，参考论文：A Faster Algorithm for Calculating Hypervolume
# 输入：
# objects 规范化后的多目标值的集合
def hypervolume(objects):
    objects.sort(key = lambda x:x[0], reverse=False) # 首先按照第1个目标值进行排序
    S = [a + [1] for a in objects] # 每行多目标值后边加一项用于求超体积的值
    S1 = []
    for k in range(len(objects[0])-1): # 逐个优化目标迭代
        # 切片
        i = 0
        if k == 0:
            x1 = 0
            while i < len(S):
                s = [b[1:] for b in S[i:]] # 提取在同一切片上的原有点和需要映射的点的剩余几个优化目标值
                # print(s)
                s_F = ENS_2(s)
                # print(s_F)
                x2 = S[i][0]
                x = x2 - x1
                # print(x)
                x1 = x2
                for c in s_F:
                    c[-1] *= x
                    S1 += [[S[i][0]] + c]

                head0 = S[i][0]
                j0 = i
                while j0 < len(S) and S[j0][0] == head0:
                    j0 += 1                
                i = j0
                # print(i)

        else: # 当不是判断第一个目标时，就只需要在之前的目标一致的范围内进一步切片
            S2 = S1
            # print(len(S))
            S1 = []
            # print(len(S2))
            while i < len(S2):
                head0 = S2[i][0:k]
                # print('head0')
                # print(head0)
                j0 = i
                while j0 < len(S2) and S2[j0][0:k] == head0:
                    j0 += 1
                S0 = [b[k:] for b in S2[i:j0]]
                # print('S[i:j0]')
                # print(S[i:j0])
                S0.sort(key = lambda x:x[0])
                # print(S0)

                x1 = 0
                j = 0
                while j < len(S0):
                    s = [b[1:] for b in S0[j:]] 
                    s_F = ENS_2(s)
                    # print(s_F)
                    x2 = S0[j][0]
                    x = x2 - x1
                    # print('x')
                    # print(x)
                    x1 = x2
                    for c in s_F:
                        c[-1] *= x
                        S1 += [head0 + [S0[j][0]] + c]

                    head1 = S0[j][0] # 求到第几个优化目标时，就用前几个目标值来判断继续切片时需要映射的点
                    j1 = j
                    while j1 < len(S0) and S0[j1][0] == head1: # 判断有多少前几个目标值相同的，如果相同则属于同一切片
                        j1 += 1
                    j = j1
                i = j0
        S = S1

    # 最后一个目标维度再求与x的乘积并求和
    vol = 0
    for d in S:
        vol += d[-1] * d[-2]

    return vol


'''计算与全局最优前沿的平均距离'''
# 输入：
# Q_best 全局最佳前沿; Q 需要求平均距离的前沿；每行形式均为[目标1，目标2，……]
# 输出：
# d 全局最优前沿与当前前沿的平均距离，越小越好
def IGD(Q_best, Q):
    d = 0
    for i in range(len(Q_best)):
        d_ks = []
        for j in range(len(Q)):
            d_k = 0
            for k in range(len(Q[0])):
                d_k += (Q_best[i][k] - Q[j][k]) ** 2
            d_ks.append(math.sqrt(d_k))
        d += min(d_ks) ** 2
    d = math.sqrt(d / len(Q_best))
    return d


'''计算分散性'''
# 输入：
# Q 需要求分散性的前沿；每行形式均为[目标1，目标2，……]
# 输出：
# ES_result 分散性指标，越小越好
def ES(Q):
    Di_set = [[1 for _ in range(len(Q))] for _ in range(len(Q))] # 为便于之后对每行进行比较取最小值，这里先令全都为1
    for i in range(len(Q)-1):
        for j in range(i+1,len(Q)):
            d = 0
            for k in range(len(Q[0])):
                d += (Q[i][k] - Q[j][k]) ** 2
            d = math.sqrt(d)
            Di_set[i][j] = d
            Di_set[j][i] = d
    Di = []
    for i in range(len(Q)):
        Di.append(min(Di_set[i]))
    D = sum(Di) / len(Q)
    ES_result = math.sqrt(sum([(a - D) ** 2 for a in Di]) / len(Q)) / D
    return ES_result


'''未被其他算法得到的前沿支配的元素的数量统计'''
# 输入：
# Q 当前方法求得的最佳前沿；Q_others 其他方法求得的最佳前沿的集合；每行形式均为[目标1，目标2，……]
# 输出：
# num 未被其他算法得到的前沿支配的元素的数量
def DPO(Q_others, Q):
    num = 0
    for a in Q:
        flag2 = 0
        for b in Q_others:
            flag = 1
            for k in range(len(a)):
                if a[k] < b[k]:
                    flag = 0 # 是否有可能被支配的标志，1表示可能，0表示不可能
                    break
            if flag == 1 and a != b:
                flag2 = 1 # 是否被支配的标志，0表示未被支配，1表示被支配
                break
        if flag2 == 0:
            num += 1
    return num


'''设计一个进度条，供后边参考使用'''  
def progress_bar(i, batches): # batches是进度条的总进度数量, i为循环标签
    length = 120 # 进度条长度
    a, b = '*' * math.floor((i + 1) / batches * length), '.' * (length - math.floor((i + 1) / batches * length))
    c = i + 1
    # time.sleep(0.5)
    if c < batches:
        print('\r', "{}/".format(c), batches, "\t[{}{}]".format(a,b), sep ='', end = "", flush = True) # 前边持续刷新
    else:
        print('\r', "{}/".format(c), batches, "\t[{}{}]".format(a,b), sep ='') # 等最后一个batch算完，之后就不再刷新当前进度条了           
    # print('\n')
    # time.sleep(0.5)


'''读取多目标函数值数据（测试算法专用）'''
if __name__ == '__main__': # 这里主要是用来避免多进程/线程时,反复重新导入数据
    # # NSGAIII_400
    # NSGA_path = os.path.join('results', 'feature_solution_' + str(feature_solution_num), 'front_NSGAIII_400_' + str(test_num) + '.csv')
    # NSGA_data = front_read(NSGA_path)
    # # 只保留每行最后一项的多个目标函数值
    # NSGA_objects = [a[-1] for a in NSGA_data]

    # # 规范化处理
    # for k in range(len(NSGA_objects[0])):
    #     min_k = min([a[k] for a in NSGA_objects])
    #     max_k = max([a[k] for a in NSGA_objects])
    #     delta = max_k - min_k
    #     for i in range(len(NSGA_objects)):
    #         NSGA_objects[i][k] = (NSGA_objects[i][k] - min_k) / delta
    # # 所有目标值都用1减一下
    # for i in range(len(NSGA_objects)):
    #     for j in range(len(NSGA_objects[0])):
    #         NSGA_objects[i][j] = 1 - NSGA_objects[i][j]
    
    NSGA_objects = [[0.9827128336112191, 0.7624599032548265, 0.6671884483805397, 0.49267983907639556], [0.9122770553514368, 0.7543505879327098, 0.7760036846715038, 0.6613930900472582], [0.8707888190484367, 0.8780473500354777, 0.0, 0.0], [0.8542377821247841, 0.751346357610172, 0.7819325387643268, 0.7155238564297655], [0.819800164886265, 0.8756439657774475, 0.005938511879955977, 0.11639007419198588], [0.8102981265434662, 0.8750431197129399, 0.37641837155426994, 0.5496614202690286], [0.8065243416396043, 0.5993474481387719, 0.8226037077632012, 0.742099518134638], [0.8032828072060648, 0.753447212287213, 0.733925066418708, 0.7963763365311475], [0.7937848871127208, 0.748342127287634, 0.7418674260353618, 0.73230040740093], [0.7902581290538506, 0.6018536953500959, 0.804232232909795, 0.7239866485295556], [0.7825191516137568, 0.03605076387045403, 0.7996961555105147, 0.7944079521477836], [0.7593115515182641, 0.8726397354549096, 0.3975344511911387, 0.6076773977880098], [0.7568177674004567, 0.5963432178162341, 0.7519745274652138, 0.7660803371712865], [0.7510293355705937, 0.5963432178162341, 0.8037282460416258, 0.7464372375548882], [0.7497712474074262, 0.8720388893904021, 0.5024261528108679, 0.7328687692683629], [0.7468234033529515, 0.5988494650275581, 0.7350804970981688, 0.7471260508101559], [0.7465051011278104, 0.5933389874936963, 0.7559867795320814, 0.7746129064518307], [0.7429698886655227, 0.5933389874936963, 0.8104082725161657, 0.7949858285144651], [0.731518267061115, 0.0330465335479162, 0.839277310605284, 0.6628661602170345], [0.7201972256762393, 0.5988494650275581, 0.8678628687703434, 0.8277355033101242], [0.714493429423491, 0.5994503110920657, 0.7736757470384912, 0.7915712471175594], [0.6970757042921406, 0.7504429819646752, 0.6885442412646544, 0.8319071085698214], [0.6963649417095675, 0.5933389874936963, 0.8032556526833814, 0.8486728080984758], [0.6892938107999345, 0.8690346590678643, 0.5642539217271253, 0.8244675221091518], [0.6858799317989817, 0.5958452347050203, 0.7610790040163194, 0.8481429046353691], [0.6796666115623593, 0.7423336666425584, 0.8291529261761452, 0.8737538916741261], [0.6722383912800525, 0.7423336666425584, 0.8196984395233233, 0.875964321349214], [0.6628093275919525, 0.7423336666425584, 0.822084176633816, 0.8806980454200689], [0.6314348007218303, 0.5903347571711585, 0.9030075429971001, 0.866190914123911], [0.6287013490892447, 0.8660304287453264, 0.5342838499655822, 0.8322551603245714], [0.6145690990145238, 0.7393294363200207, 0.8382055762436441, 0.8978206157918228], [0.6034436551022019, 0.02703807290284055, 0.9584936347561566, 0.8496812056255653], [0.5830802517184716, 0.7444345213195995, 0.7214644704630947, 0.8378488319036308], [0.5803416957119846, 0.8636270444872961, 0.5399116934450326, 0.8322143897350159], [0.5642230188106505, 0.023432996515795, 0.8784202450969703, 0.8816121980787338], [0.5570296693139619, 0.7414302909970616, 0.7211807114032831, 0.897431322629782], [0.547790812523832, 0.7363252059974827, 0.788774745568783, 0.9076729225174514], [0.5384435831672134, 0.7350798174814555, 0.8422942809303473, 0.8894022285533972], [0.5379923172063608, 0.7363252059974827, 0.807047862262548, 0.9077284790017881], [0.5333827517245905, 0.024033842580302722, 0.9704147761605284, 0.8815200813023235], [0.5180158859354446, 0.7333209756749449, 0.8176382570176248, 0.9159831953274956], [0.5127911945535994, 0.5843262965260827, 0.8062510757177068, 0.9194737036260837], [0.49716460190778744, 0.021029612257764896, 0.901899012977495, 0.9333614596714778], [0.4962458468868881, 0.7333209756749449, 0.8211674406840898, 0.9159026757117201], [0.4944100313833568, 0.7333209756749449, 0.8051729478923098, 0.9159998288930727], [0.47536904314328865, 0.021029612257764896, 0.9805186543160772, 0.9045119281175791], [0.46840615155512944, 0.7320755871589175, 0.8416143473301362, 0.9039954310710437], [0.44536205939117635, 0.48867906500501623, 0.8495428224605646, 0.910861524939238], [0.4452221361384143, 0.583828313414869, 0.7733123602370151, 0.9255374798185577], [0.44154498973743006, 0.01802538193522707, 0.8878020879516778, 0.9333647407773966], [0.42437259977127295, 0.7303167453524071, 0.7894867858543572, 0.9181319592682279], [0.4233827568211007, 0.5814249291568387, 0.8388614038028943, 0.9530000457040638], [0.38974036808384926, 0.4856748346824784, 0.8400011260593034, 0.9151344810982236], [0.3681624438465232, 0.7273125150298693, 0.7896932720072853, 0.9180318312175089], [0.3592889191380525, 0.7273125150298693, 0.8119112043439841, 0.944919119521641], [0.3515578806933375, 0.727913361094377, 0.7832835630734201, 0.9377985867974984], [0.3405670148817814, 0.015021151612689243, 0.8389201942169209, 0.9416414346345522], [0.3309445672750039, 0.5753136055584693, 0.8879734661592512, 0.9424858132378188], [0.3291353286327585, 0.5778198527697932, 0.7847482608588284, 0.9545027901904346], [0.3216394256383672, 0.012016921290151306, 0.8813564544250816, 0.9527838125603945], [0.31472627392857877, 0.7294133697069103, 0.7742255665201343, 0.9379002329053974], [0.29417013611707243, 0.5778198527697932, 0.8184029785122489, 0.9558841053954554], [0.28567193579609207, 0.7294133697069103, 0.786814384559067, 0.9543490227923814], [0.2531379369689919, 0.7249091307718392, 0.8225743386256623, 0.9332879797077359], [0.23710253485890975, 0.848605892874607, 0.5114607585783125, 0.9039507706939452], [0.23531242289530074, 0.7219049004493012, 0.7815058085450927, 0.9569652115382786], [0.23477772663317764, 0.5748156224472554, 0.8057284823780084, 0.9569728977181984], [0.2300523236257348, 0.7264091393843725, 0.779203780236359, 0.956913247306651], [0.2040227048807428, 0.7219049004493012, 0.7950769738149351, 0.9539452028504091], [0.1984808161305418, 0.7234049090618346, 0.7908082268425913, 0.9645512668366316], [0.17323513140119873, 0.5663009145908557, 0.8569131094439155, 0.9615672474980324], [0.16160264645630895, 0.5688071618021797, 0.7768073554986942, 0.9782192905566965], [0.15424981526802928, 0.0030042303225378264, 0.9122445486519727, 0.9919410956899541], [0.15056351022924896, 0.006008460645075653, 0.8361675426832519, 0.9677033080485555], [0.14779538353963295, 0.7189006701267635, 0.8155801831688743, 0.966459404140003], [0.1311926818040714, 0.006008460645075653, 0.8363226505690133, 0.961872515553426], [0.12092201244569944, 0.7152955937397178, 0.8433312132458544, 0.9612843898889826], [0.11802416456511444, 0.46764945274725134, 0.8625885687291004, 0.9474827803590183], [0.09264455859778076, 0.7110459749011527, 0.7758452267340822, 0.9711619317947333], [0.08422528550683661, 0.0, 0.9165442222762932, 0.9991009414569524], [0.08007370843602635, 0.717396448416759, 0.783143313350529, 0.9727753097938059], [0.07480884119633735, 0.47065368306978916, 0.8330811150265709, 0.961651275626515], [0.0, 0.46764945274725134, 0.8070079509237138, 0.9745602592546646]]

    # NSGA_objects = [[4,2,1],[3,1,2],[2,3,3],[1,2,4]]

    # 求超体积
    vol = hypervolume(NSGA_objects)
    print(vol)

# Front = [[4,2,1],[3,1,2],[2,3,3],[1,2,4]] # 测试算法用